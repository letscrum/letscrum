# letscrum

## Generate API

```text
make api_gen
```

## Add Service
- Add RegisterDemoHandler generated by proto in internal/cmd/gateway.go file
    ```go
    func NewGateway(ctx context.Context, conn *grpc.ClientConn, opts []runtime.ServeMuxOption) (http.Handler, error) {
    
        mux := runtime.NewServeMux(opts...)
    
        for _, f := range []func(context.Context, *runtime.ServeMux, *grpc.ClientConn) error{
            // Add follow line, it is generated by protoc
            v1.RegisterDemoHandler,
        } {
            if err := f(ctx, mux, conn); err != nil {
                return nil, err
            }
        }
        return mux, nil
    }
    ```
- Create demo.go file in internal/service folder and implement the proto service apis
    ```go
    type DemoService struct {
        // This is generated by protoc
        letscrumv1.UnimplementedDemoServer
        // Add follow line if you need database operate
        dao dao.DemoDao
    }
  
    func NewDemoService(dao dao.Interface) *DemoService {
        return &DemoService{dao: dao.DemoDao()}
    }
    ...
    // Service implementation code
    ...
    ```
- Add new demo func in internal/service/main.go file
    ```go
    func (s *Service) DemoService() DemoService {
        return *NewDemoService(s.dao)
    }
    ```
- Add RegisterDemoServer generated by proto in internal/cmd/grpc/grpc.go file

## Add DAO if you need database (GORM) [Optional]
- Add demo.go dao in internal/dao folder and define interface
- Implement dao interface in demo.go in internal/dao/mysql with New func
- Add gorm implement func in internal/dao/mysql/main.go file
- Add the new dao in interface of internal/dao/main.go file
