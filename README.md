# letscrum

## Generate API

```text
make api_gen
```

## Add Service without Datbase Operate

- Proto file definition

    ```proto
    service Demo {
        rpc Demo(letscrum.api.general.v1.DemoRequest) returns (letscrum.api.general.v1.DemoResponse) {
            option (google.api.http) = {
                get: "/api/v1/demo"
            };
        }
    }
    ```

    ```proto
    message Demo {
        string demo = 1;
    }

    message DemoRequest {
        string demo = 1;
    }

    message DemoResponse {
        Demo demo = 1;
    }
    ```

- Add RegisterDemoHandler generated by proto in internal/cmd/gateway.go file

    ```go
    func NewGateway(ctx context.Context, conn *grpc.ClientConn, opts []runtime.ServeMuxOption) (http.Handler, error) {
    
        mux := runtime.NewServeMux(opts...)
    
        for _, f := range []func(context.Context, *runtime.ServeMux, *grpc.ClientConn) error{
            // Add follow line, it is generated by protoc
            v1.RegisterDemoHandler,
        } {
            if err := f(ctx, mux, conn); err != nil {
                return nil, err
            }
        }
        return mux, nil
    }
    ```

- Create demo.go file in internal/service folder and implement the proto service apis

    ```go
    type DemoService struct {
        // This is generated by protoc
        letscrumv1.UnimplementedDemoServer
        // Add follow line if you need database operate
        // dao dao.DemoDao
    }
    
    func NewDemoService() *DemoService {
        return &DemoService{}
    }
    // Replace to follow func if you need database operate
    // func NewDemoService(dao dao.Interface) *DemoService {
    //     return &DemoService{dao: dao.DemoDao()}
    // }

    ...
    // Service implementation code
    ...
    ```

- Add new demo func in internal/service/main.go file

    ```go
    func (s *Service) DemoService() DemoService {
        return *NewDemoService()
        // Replace to follow line if you need database operate
        // return *NewDemoService(s.dao)
    }
    ```

- Add RegisterDemoServer generated by proto in internal/cmd/grpc/grpc.go file

    ```go
    // ...
    var daoInterface dao.Interface
    if daoInterface, err = initDao(); err != nil {
        return err
    }
    // ...
    // Other services register code
    // ...
    demoService := service.NewDemoService()
    // This is generated by protoc
    v1.RegisterDemoServer(s, demoService)

    // ...
    // Other code
    // ...
    go func() {
        defer s.GracefulStop()
        <-ctx.Done()
    }()
    // ...
    ```

- Implemente Demo API in internal/service/demo.go file

    ```go
    func (s *DemoService) Demo(ctx context.Context, req *generalv1.DemoRequest) (*generalv1.DemoResponse, error) {
        return &generalv1.DemoResponse{
            Demo: &generalv1.Demo{
                Demo: req.Demo,
            },
        }, nil
    }
    ```

## Add Service with Database Operate

- Proto file definition

    ```proto
    service DemoDb {
        rpc DemoDb(letscrum.api.general.v1.DemoDbRequest) returns (letscrum.api.general.v1.DemoDbResponse) {
            option (google.api.http) = {
                get: "/api/v1/demodb"
            };
        }
    }
    ```

    ```proto
    message DemoDb {
        string demo_db = 1;
    }

    message DemoDbRequest {
        string demo_db = 1;
    }

    message DemoDbResponse {
        DemoDb demo_db = 1;
    }
    ```

- Add demodb.go in internal/model folder with model definition

    ```go
    type DemoDb struct {
        Model

        DemoDb string `json:"demo_db"`
    }
    ```

- Add demodb.go dao in internal/dao folder and define interface

    ```go
    type DemoDbDao interface {
        DemoDb(ctx context.Context, demoDb string) (*model.DemoDb, error)
    }
    ```

- Implement dao interface in demodb.go in internal/dao/mysql with New func

    ```go
    type DemoDbDao struct {
        Db *gorm.DB
    }

    // Implementation interface code
    func (d DemoDbDao) DemoDb(ctx context.Context, demoDb string) (*model.DemoDb, error) {
        // This is a demo code ignore it if you have real database logic
        dDb := &model.DemoDb{
            DemoDb: demoDb,
        }
        // Add GORM logic here
        // if err := d.Db.Where("name = ?", name).Find(&dDb).Error; err != nil {
        //     return nil, err
        // }
        return dDb, nil
    }
    
    func NewDemoDbDao(d *gorm.DB) *DemoDbDao {
        return &DemoDbDao{d}
    }
    ```

- Add gorm implement func in internal/dao/mysql/main.go file

    ```go
    func (d *Dao) DemoDbDao() dao.DemoDbDao {
        // There could be added success after interface implement
        return NewDemoDbDao(d.Db)
    }
    ```

- Add the new dao in interface of internal/dao/main.go file

    ```go
    type Interface interface {
        // ...
        // Other dao interfaces
        // ...
        DemoDbDao() DemoDbDao
    }
    ```

- Add RegisterDemoDbHandler generated by proto in internal/cmd/gateway.go file

    ```go
    func NewGateway(ctx context.Context, conn *grpc.ClientConn, opts []runtime.ServeMuxOption) (http.Handler, error) {
    
        mux := runtime.NewServeMux(opts...)
    
        for _, f := range []func(context.Context, *runtime.ServeMux, *grpc.ClientConn) error{
            // ...
            // Other code
            // ...
            // Add follow line, it is generated by protoc
            v1.RegisterDemoDbHandler,
        } {
            if err := f(ctx, mux, conn); err != nil {
                return nil, err
            }
        }
        return mux, nil
    }
    ```

- Create demodb.go file in internal/service folder and implement the proto service apis

    ```go
    type DemoDbService struct {
        // This is generated by protoc
        letscrumv1.UnimplementedDemoDbServer
        // Remove follow line if you don't need database operate
        dao dao.DemoDbDao
    }

    func NewDemoDbService(dao dao.Interface) *DemoDbService {
        return &DemoDbService{dao: dao.DemoDbDao()}
    }

    // Replace to follow func if you don't need database operate
    // func NewDemoDbService() *DemoDbService {
    //     return &DemoDbService{}
    // }
    
    ...
    // Service implementation code
    ...
    ```

- Add new demo func in internal/service/main.go file

    ```go
    func (s *Service) DemoDbService() DemoDbService {
        return *NewDemoDbService(s.dao)
        // Replace to follow line if you don't need database operate
        // return *NewDemoService()
    }
    ```

- Add RegisterDemoDbServer generated by proto in internal/cmd/grpc/grpc.go file

    ```go
    // ...
    var daoInterface dao.Interface
    if daoInterface, err = initDao(); err != nil {
        return err
    }
    // ...
    // Other services register code
    // ...
    demoDbService := service.NewDemoDbService(daoInterface)
    // This is generated by protoc
    v1.RegisterDemoDbServer(s, demoDbService)

    // ...
    // Other code
    // ...
    go func() {
        defer s.GracefulStop()
        <-ctx.Done()
    }()
    // ...
    ```

- Implemente Demo API in internal/service/demodb.go file

    ```go
    func (s *DemoDbService) DemoDb(ctx context.Context, req *generalv1.DemoDbRequest) (*generalv1.DemoDbResponse, error) {
        demoDb, err := s.dao.DemoDb(ctx, req.DemoDb)
        if err != nil {
            result := status.Convert(err)
            if result.Code() == codes.NotFound {
                return nil, status.Errorf(codes.NotFound, "get err: %s not found", req.DemoDb)
            }
            return nil, status.Error(codes.Unknown, err.Error())
        }
        return &generalv1.DemoDbResponse{
            DemoDb: &generalv1.DemoDb{
                DemoDb: demoDb.DemoDb,
            },
        }, nil
    }
    ```

